<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>整活 on StarWhisper</title>
    <link>https://blog.frostmiku.com/categories/%E6%95%B4%E6%B4%BB/</link>
    <description>Recent content in 整活 on StarWhisper</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 30 Jun 2021 15:22:00 +0800</lastBuildDate><atom:link href="https://blog.frostmiku.com/categories/%E6%95%B4%E6%B4%BB/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>基于肢体运动的睡眠状态检测原理</title>
      <link>https://blog.frostmiku.com/archives/36/</link>
      <pubDate>Wed, 30 Jun 2021 15:22:00 +0800</pubDate>
      
      <guid>https://blog.frostmiku.com/archives/36/</guid>
      <description>背景  睡眠，作为人类每天都要进行的一项活动，它占据了人类整个生命周期的三分之一左右，其质量的高低对人类身心健康有着巨大的影响。
 良好的睡眠质量有助于身体成长、提高大脑记忆能力、增强自身免疫力，同时有利于集中注意力，保证各方面均衡发展，是健康的基本保证。然而，现如今的年轻人或是因为繁重的学习生活压力，或是因为精彩缤纷的互联网世界，熬夜成瘾，久久无法入眠。
 来自洛阳市精神卫生中心的调查显示大部分学生能够认识到睡眠质量与学习、工作的直接关联，也非常重视自身的睡眠质量，但是却没有为改善自己的睡眠质量做出过努力1。
 据报告，在美国，有15%至60%的严重交通事故是由睡眠问题所造成的2，因睡眠问题导致的各类财务损失超过几百亿美金3。
 睡眠质量的高低与人类健康息息相关，较差的睡眠质量会导致情绪低落、注意力涣散、反应迟钝、免疫力下降等症状，严重情况下，熬夜者很可能会有猝死的风险。
 近年来，随着物质生活水平的不断提高，人们的健康意识逐渐增强，对人生三分之一都在进行的大事——“睡眠”自然也是十分关注。
 随着对睡眠的医学研究全面深入，和传感器技术的飞速发展，为人们优化自己的睡眠质量提供了新的可能。
 睡眠质量的高低与人类健康息息相关，较差的睡眠质量通常会导致许多疾病的发病率升高，严重情况下，熬夜者很可能会有猝死的风险。通常我们可以依据睡眠者起床时的精神面貌来评判睡眠质量的高低，而睡眠者被唤醒的时机是影响起床时精神面貌的关键因素之一。
 图 1 睡眠样本 
 如图1所示，医学界通常认为睡眠过程是一个由快速动眼期(REM)和非快速动眼期(NREM)两大时序状态组成的循环过程，其中，非快速动眼期阶段又可以细化为以下四个睡眠子阶段：第一、二阶段统称为浅睡眠过程(Light Sleep)，第三、四阶段统称为深睡眠过程(Deep Sleep)4。当睡眠者在深睡眠过程中被外界因素唤醒时，将会产生梦中惊醒的效果，睡眠者的精神面貌也必不会有多好。然而，当睡眠者在浅度睡眠时受外界因素被唤醒时，则会表现出自然睡醒一样的效果5。
睡眠周期及睡眠状态检测原理 睡眠周期  人类的睡眠存在一个生物节律，即大约在90到100分钟的时间内，经历五个不同阶段的周期，国际睡眠医学将睡眠阶段分为五期：入睡期、浅睡期、熟睡期、深睡期和快速动眼期。
 入睡期是睡眠的开始，昏昏欲睡的感觉就属于这一阶段。浅睡期开始正式睡眠。熟睡期和沉睡期是沉睡阶段，在该阶段人不容易被叫醒。当睡眠者由浅睡期或快速动眼期逐步进入沉睡期时，睡眠者的呼吸频率和心跳速度均会减慢且变得有节奏，其血压也会降低。与此同时，脑电波开始变慢并且会呈现出大量高幅值的波段6。
 以上四个阶段睡眠共要经过约60到90分钟。而且均不会出现眼球快速跳动现象，故统称为非快速动眼睡眠。
 最后一个时期被称为快速动眼期。顾名思义，此时的睡眠者会出现动眼现象，此时的睡眠者通常会有翻身的动作，并且容易惊醒。科学研究表明，快速动眼期是大脑内部对记忆的学习和技巧的快速整合阶段。这一阶段的睡眠质量直接决定了睡眠者的记忆和理解效率，是非常重要的睡眠阶段7。所以保证足够的睡眠时间是非常重要的。
 图 2 睡眠过程状态迁移图 
 睡眠周期是由睡眠刚启动的昏昏欲睡逐渐变沉，经由非快速动眼期（慢波睡眠期）和快速动眼期（异相睡眠期），这几个睡眠阶段之间的往复循环。又称为短昼夜睡眠周期，睡梦周期或快速动眼—非快速动眼(REM-NREM)周期，以示区别于睡眠和清醒间的昼夜交替。如图1所示人类的睡眠周期约70至110分钟（90±20分钟）8。医学上又可以将睡眠细粒度地分为如图2所示的五个阶段：
 第一阶段(S1)也是非快速动眼期第一阶段，是睡眠的最初状态，也是睡眠者由清醒逐渐进入到浅睡眠状态的过程。睡眠者在该阶段通常会出现突然地肌肉颤动，容易受到外部环境的干扰。 第二阶段(S2)是相较于第一阶段(S1)更深程度的睡眠阶段。但其仍然属于浅睡眠阶段。在该阶段中，睡眠者身体温度开始下降，并且心率开始减慢。这个阶段通常持续约20分钟左右，是睡眠者从浅睡眠进入深睡眠的过程。 第三阶段(S3)是睡眠者进入深睡眠阶段中的第一阶段。睡眠者的血压开始降低，呼吸频率进一步减慢，与此同时，身体体温再次下降，变得更低。睡眠者在该阶段很少出现身体运动。如果此时将睡眠者唤醒，那么他/她的精神面貌将会很差，并且容易导致注意力不集中等症状。 第四阶段(S4)是深睡眠过程中的第二个阶段，也是整个过程中睡眠程度最深的阶段。是深睡眠过程中的第二个阶段，也是整个过程中睡眠程度最深的阶段。该阶段持续大约30分钟。 第五阶段(S5)是快速动眼期(REM), 也是整个睡眠过程中睡眠者脑部活动最为活跃的阶段。在此阶段中，睡眠者的脑电波通常很快且变化迅速，形状与清醒状态下相类似9。  通过肢体运动检测睡眠状态  在不同的睡眠阶段，睡眠者通常会表现出不同的肢体运动行为。从医学角度看, 在浅睡眠阶段，睡眠者的心跳频率通常较快，从而容易导致较大的身体动作，比如翻身等现象。相反，一些微小的身体动作经常会发生在深睡眠阶段。此外，在快速动眼期，睡眠者脑电波处于较为活跃的状态，在该阶段睡眠者多梦，由此会引发一些无意识的身体动作，手臂拉伸、腿部伸展等肢体活动经常发生于该阶段。因此给通过肢体运动行为进行睡眠者睡眠状态推测提供了依据。
 在图2中的S1阶段中睡眠者的眼部运动和身体肌肉运动开始减少，逐步进入休息状态。睡眠者在该阶段通常会出现突然地肌肉颤动，容易受到外部环境的干扰，之后的几个阶段中肢体动作依次递减。直至S5阶段睡眠者的呼吸速度开始加快，变得不规律。与此同时，睡眠者在此阶段通常多梦，其眼部运动开始加剧，嘴部及肌肉活动变得频繁起来。
 在一次正常的睡眠过程中，睡眠者通常会由浅睡眠阶段变换至深睡眠阶段，接着并不直接进入快速动眼期，而是从深度睡眠逆向回到浅度睡眠，之后才进入快速动眼期。快速动眼期结束后，接着再进入S1阶段，如此周而复始。睡眠过程中的状态变换在时间上呈现出周期性规律，不同睡眠状态之间的切换也具有一定的依赖性与时序性。一次完整的睡眠状态周期大约会持续90分钟，并且一晚上大约循环4到6次。
实现  这部分我就不放出来了，基本就是拿到加速度传感器三轴的值然后归一化，然后进行识别，马尔科夫链或是条件随机场都是很好的方法，当然我更推荐后者，因为前者认为所有显式状态是彼此独立的，在建模中并不考虑他们之间的依赖关系。考虑到睡眠过程中各个睡眠相关事件的相互依赖性，相比于隐式马尔科夫链，条件随机场能够描述更多特征，从而达到更好地预测效果。
 数据处理 
而我为了混个毕业就直接有限状态机解决问题了。差不多得了
 总体架构 
Reference   郑伟,赵静霞.</description>
    </item>
    
    <item>
      <title>仿手写文本生成</title>
      <link>https://blog.frostmiku.com/archives/35/</link>
      <pubDate>Tue, 29 Jun 2021 21:52:28 +0800</pubDate>
      
      <guid>https://blog.frostmiku.com/archives/35/</guid>
      <description>事情的起因是这样的&amp;hellip;
当年正是疫情最为严峻的时候，学校决定网上开学（云上课）
那么开学了，就得写作业 淦
其中有一门毛中特，老师比较有想法，作业不收电子版，要求手写拍照提交
那我作为一个键盘侠，面对这么抗拒时代洪流的做法当然是不同意的呀！
于是我上网搜索了一番，搜出来了这么个玩意
淦，今天写文章时才发现他也是为了对付毛概
有一说一，如果不用交给老师的话效果还真不错
但拿来交作业的话，老师找两个一样的字一对比，直接喜提零分回家了（
于是我在想，能不能给每个字加入随机扰动
结果还真让我找到了一个叫 handright 的 Python 包
接下来就是无聊的调参过程了，最终效果如下：
 效果 
因为生成的是位图，所以一放大就会发现锯齿
按理说应该搞个抗锯齿的，然而马上就要收作业了
我选择用 HiDPI 的方法应付一下得了（
 Before   After 
先生成一张高分辨率的图，然后再手动缩小
然后使用 QQ 截图！如果效果还不好的话，就压缩一下，把图片弄糊
或者换个不会放大图片的老师
也不知道这玩意拿来打印效果怎么样（
项目已在 GitHub 上开源：传送门
ps: 这项目收到18元赞助，拿去 CSGO 开了个箱子，变成了破铜烂铁（</description>
    </item>
    
    <item>
      <title>大革命，一种扑克卡牌游戏</title>
      <link>https://blog.frostmiku.com/archives/34/</link>
      <pubDate>Fri, 09 Apr 2021 17:55:35 +0800</pubDate>
      
      <guid>https://blog.frostmiku.com/archives/34/</guid>
      <description>前言 最近接触了一种名叫“大富豪”(译名之一)的传统日式扑克牌游戏，国内好像知者甚少，故在此分享。
简介 “大富豪”是一种类似我国斗地主规则的扑克游戏，游戏擅长以大逆转来炒热氛围。
由于“大富豪”的名称、玩法规则各个地区都有差异（类似我国麻将）
这里我主要介绍一种由我进行本地化改造的版本“大革命”。
其实规则大体上和斗地主相似，如果会玩斗地主只需要看下相异之处即可。
哦对了，游戏需要四个人来进行（当然你也可以自己修改
基础规则 场次 一局游戏由多场组成，并由最后一场排名决定游戏最终排名，所以在最后一场之前即使是倒数第一也没关系！
推荐一局游戏场数：五场 或 十场
单场胜利：第一个出完手牌的人为第一名，其他人依次决出第二第三和第四名。
在每场开局时，随机抽出一张卡牌从游戏中除外，用来平衡卡牌数量并防止算牌。再下一场开始时，将上一场除外的这张牌加回牌堆并重新抽出一张牌除外。
上下家 上家：在你之前出牌的那个人
下家：你出牌后出牌的那个人
卡牌强度 由弱到强依次为 3&amp;hellip;K&amp;hellip;2
即3最小，2最大，鬼牌稍后再说。
出牌 一场游戏由多轮出牌阶段构成。每轮的首位出牌者称为该轮的主导者
主导者可以打出如下所示的任意一种类型的任意牌，其他三家继续依照你的出牌类型接牌。
第一场开始时由参赛玩家自行决定由谁当主导者，即由谁开始出牌。
之后几场开始时由第四名率先出牌。
可选出牌类型 单牌：一张牌
对子：两张一样的牌
顺子：三张一样的牌
链子：连续三张（或以上）同样花色的牌（例：红桃A 红桃2 红桃3 红桃4）
大革命：四张相同的牌
接牌 你必须打出比你上家更大的同类型牌，即，你的上家出链子 3 4 5 时，你必须也出链子，且强度至少为 4 5 6，当然你也可以选择不出，来跳过你的回合，由下家出牌。
当你打出牌后，其他三家都选择不出时，本轮接牌结束。你成为新一轮的主导者。
大革命 当你打出大革命（即四张相同牌）时，如果没有人接上，将会进入革命阶段，此时卡牌强队将会发生反转！
即由原来的 3最小2最大，变为2最小，3最大。
如果有人接上，卡牌强度将不会发生变化，视为革命发动失败，当然下家仍然可以继续接牌来发动大革命。（下下家还能接牌反制
8切 当你打出的牌型（单牌/对子/顺子/链子/大革命）中含有8时，其他三家不能接牌，必须选择不出。你成为主导者。
鬼牌 在本游戏中，鬼牌只有一张，所以游戏开始前请先将一张鬼牌除外。一副扑克牌54张，除外一张鬼牌 并且 每场开始前除外一张牌，正好剩下52张，每人13张牌，合理！
鬼牌，视为最大的牌，并不受大革命影响，即它在平时比 2 大，在革命时比 3 大。
鬼牌可以冒充任意一张牌使用，即它可以配牌，你可以通过配牌发动大革命，但当鬼牌冒充8的时候，没有8切效果。
鬼牌不能最后打出，否则视为犯规，直接变成第四名！如果犯规者不是本场游戏的第一名，则此时不会触发一落千丈。
黑桃3 黑桃3可以反制鬼牌，当鬼牌单张打出时，可以打出黑桃3进行反制，此时打出黑桃三者成为主导者。
一落千丈 上一场的第一如果本场没能成为第一，则当新的第一产生时他被迫成为第四名，手中的牌直接放入弃牌堆（扣着，不能公示给其他三家看）。剩下两人决出第二第三名。
收税 第四向第一交出最大的两张牌，第三向第二交出最大的一张牌。</description>
    </item>
    
    <item>
      <title>浅谈邀请码的生成</title>
      <link>https://blog.frostmiku.com/archives/33/</link>
      <pubDate>Tue, 09 Feb 2021 01:53:00 +0800</pubDate>
      
      <guid>https://blog.frostmiku.com/archives/33/</guid>
      <description>今天自己写项目玩，想要实现一个类似邀请码的机制，没想到小小邀请码还真没那么简单
需求分析 首先是硬性需求：
 不可重复 单射  看到这两点需求，我第一反应就是 Hash，但是Hash需要处理冲突，并不是一个很好的解决方案。另外出于美学之类的考虑，我们还有一些别的需求，毕竟谁也不想面对面分享邀请码的时候拿出来一串 18ce3ca04a725cc6b57d5ec0ae0ccd66 这样的乱码吧
非硬性需求：
 定长 不易被推测出规律 效率高 支持并发 可溯源  仔细思考了一下 Hash 的可行性后我决定放弃这种方案&amp;hellip;
方案分析 群里的菊苣给出了洗牌算法的方案，这是一个预生成的方案 这里就预生成方案统一分析
预生成 讲真，不考虑别的因素，预生成方案确实不错，洗牌算法也非常的棒
这种方案的思想是根据随机生成算法，预先生成一批邀请码，然后将这些邀请码缓存，当用户请求时将其分配给用户，当邀请码分配完时，再生成一批，如此循环。
弊端  每次重新生成时都要检查是否重复 而且多数情况下都为否 邀请码本身需要持久化存储 用户和邀请码的关系需要记录  对于唯一性我啪的一下就想到了 UUID 和 MD5，很快啊 MD5作为一种 Hash 在一开始就被我放弃了，接下来我们看一下 UUID
UUID 引用一下Wikipedia的说法
 通用唯一识别码（英语：Universally Unique Identifier，缩写：UUID）是用于计算机体系中以识别信息数目的一个128位标识符，根据标准方法生成，不依赖中央机构的注册和分配，UUID具有唯一性，这与其他大多数编号方案不同。重复UUID码概率接近零，可以忽略不计。
 这下唯一性是真的强，但是分享一串128位标识符的画面确实也很美&amp;hellip;
没啥好想法的我上网搜了一下，又得到了两种方案，一种类似于Base64，这种没啥好说的，接下来主要说一下另一种方案
密码学方案 这种方案本质上是一个实现了由 用户ID空间 到 邀请码空间 的双射，通过用户ID确定了邀请码的唯一性，同时又可通过反函数来对邀请码溯源，既不需要保存邀请码，又不需要保存关系，针不戳
我们先来写个简单函数实现双射
func test(id uint) { const Chars = &amp;#34;0123456789ABCDEF&amp;#34; const CodeLength = 6 const Base = 16 const Salt = 233 pid := id + Salt // 为了避免用户 ID的直接泄漏，我们可以先加点盐 	var b [CodeLength] uint b[0] = pid for i := 0; i &amp;lt; CodeLength-1; i++ { b[i + 1] = b[i] / Base b[i] = b[i]% Base } fmt.</description>
    </item>
    
    <item>
      <title>OpenCore打造一个完美的 Hackintosh 遇到的问题</title>
      <link>https://blog.frostmiku.com/archives/28/</link>
      <pubDate>Thu, 16 Jul 2020 23:18:41 +0800</pubDate>
      
      <guid>https://blog.frostmiku.com/archives/28/</guid>
      <description>主板是 msi z370 a pro，草草记录，待日后完善
 开机崩溃重启 启动参数加 -v 看看情况。
如果是内存panic但又怎么都解决不了，考虑一下核显显存，BIOS设置 64 MB
开机两阶段苹果logo大小不一样 UIScale 调一下 1 或者 2
睡眠 休眠不建议开，对于台式机来说不存在节电续航的需求，并且休眠还会产生内存向硬盘的大量数据读写，影响硬盘寿命
但睡眠还是必要的。
睡眠秒醒，唤醒后崩溃重启 使用hackintool进行usb定制，把常用设备内建。
PowerTimeoutKernelPanic: 10.15系统中存在一些设备自身的电源管理无法让系统进入睡眠而超时，导致内核奔溃，如果有这个问题请选择YES。
有线音频输出声音小 换个layout-id试试，我这块板子用的“1”
博通无线网卡开机时网速慢，必须手动关掉重开wifi / 睡眠唤醒后没网、网速慢 使用 AirportBrcmFixup.kext 修复</description>
    </item>
    
    <item>
      <title>编译原理学习笔记：文法与语言</title>
      <link>https://blog.frostmiku.com/archives/20/</link>
      <pubDate>Fri, 21 Feb 2020 23:00:00 +0800</pubDate>
      
      <guid>https://blog.frostmiku.com/archives/20/</guid>
      <description>前言 本学期开了编译原理课，嗯写作本文的原因就这么简单&amp;hellip;
基本概念  字母表：非空有限集，一般用$∑$表示，如$∑＝{a,b,c}$ 符号： $∑$中的元素称为符号。 符号串：符号的有穷序列称符号串，也可称为字，用ε表示空字符串。 长度：符号串中包括的符号的个数，如$|ab|＝2,|ε|＝0$ 连接：设x和y是字符串，则称$x·y$是其连接，符号‘·’一般可省略。 对于任意字符串$β$，有$βε＝εβ＝β$ 乘积：设A和B是符号串集，则用AB表示它们的乘积：  $$ AB＝{xy|x∈A,y∈B } $$
显然${ε}A=A{ε}=A$
 空集：不含任何元素的集合φ，对任何字符串集A有：  $$ φA＝Aφ＝A $$
 方幂：设A是字符串集，则A的方幂定义为：  $$ A^0 ={ε}; A^1 ＝A; A^n ＝A^{n-1} A $$
特别地，若x是$∑$中的字符，则x的n次自身连接即$x^n$
 闭包/正闭包/星闭包：设A是符号集， 用$A^+$表示A的正闭包:  $$ A^+=A^1∪A^2∪\dots∪A^n∪\dots $$
用$A^*$表示A的星闭包:
$$ A^*＝A^0∪A^1∪A^2∪\dots∪A^n∪\dots={ε}∪A^+ $$
两者统称为A的闭包。
举个例子1： 设$A = {a,b}$ 则：
$$ \begin{aligned} &amp;amp;A^0 ＝ {ε}\cr &amp;amp;A^1 = {a,b}\cr &amp;amp;A^2 = AA = {aa,ab,ba,bb}\cr &amp;amp;A^3 = AAA = {aaa,aab,aba,abb,baa,bab,bba,bbb}\cr &amp;amp;\dots\cr \end{aligned} $$</description>
    </item>
    
    <item>
      <title>使用 JavaScript 实现一个基于 FSM 的 http 请求头 parser</title>
      <link>https://blog.frostmiku.com/archives/17/</link>
      <pubDate>Mon, 17 Feb 2020 16:20:00 +0800</pubDate>
      
      <guid>https://blog.frostmiku.com/archives/17/</guid>
      <description>目标 HTTP/1.1 200 OKServer: nginxDate: Sun, 05 Jan 2020 17:39:08 GMTContent-Type: text/html; charset=UTF-8Connection: closeVary: Accept-EncodingX-Powered-By: PHP/5.6.10Content-Length: 6123Abc&amp;ndash;&amp;gt; parse &amp;ndash;&amp;gt;
{ &amp;#34;reqline&amp;#34;: &amp;#34;HTTP/1.1 200 OK&amp;#34;, &amp;#34;headers&amp;#34;: { &amp;#34;server&amp;#34;: &amp;#34;nginx&amp;#34;, &amp;#34;date&amp;#34;: &amp;#34;Sun, 05 Jan 2020 17:39:08 GMT&amp;#34;, &amp;#34;content-type&amp;#34;: &amp;#34;text/html; charset=UTF-8&amp;#34;, &amp;#34;connection&amp;#34;: &amp;#34;close&amp;#34;, &amp;#34;vary&amp;#34;: &amp;#34;Accept-Encoding&amp;#34;, &amp;#34;x-powered-by&amp;#34;: &amp;#34;PHP/5.6.10&amp;#34;, &amp;#34;content-length&amp;#34;: &amp;#34;6&amp;#34;, } &amp;#34;body&amp;#34;: &amp;#34;123Abc&amp;#34; } 状态机  http parser fsm 
代码实现 var httpParser = {}; (function () { function Stream (str) { this.</description>
    </item>
    
    <item>
      <title>Arch Linux (Manjaro) 配置、美化与常用软件安装指南（</title>
      <link>https://blog.frostmiku.com/archives/14/</link>
      <pubDate>Sat, 30 Nov 2019 19:06:00 +0800</pubDate>
      
      <guid>https://blog.frostmiku.com/archives/14/</guid>
      <description>前言 之前就一直有在用Manjaro，主要是自己懒得安装Arch Linux，最近看 @KAAAsS写了一篇KDE桌面环境的Manjaro配置，没忍住就装了一个，结果KDE和我还是不太兼容（
所以我就跑过来写一篇Gnome的同名文章，嘿嘿。
欢迎邮件联系 i@frostmiku.com
注意 本文作如下约定：
 如无特别说明，本文的**&amp;ldquo;安装&amp;rdquo;**是指使用pacman包管理器命令或其图形化前端在**已添加archlinuxcn源**情况下进行的软件包安装**或**AUR构建。
如无特别说明，本文的**“编辑”**指的是使用任何图形或非图形化文本编辑器对目标文件的编辑。Gnome环境下可以使用 sudo gedit path 来打开文件进行编辑。
 配置 软件源与镜像 减少重复造轮子，请移步这里：
 https://blog.kaaass.net/archives/1205#toc-4
 或者，你只是想快速完成这些步骤而不想详细了解的话：
#切换中国源sudo pacman-mirrors -c China#添加 [archlinuxcn]sudo gedit /etc/pacman.conf# 然后在弹出来的 gedit 最下方追加如下内容[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch#更新软件源pacman -Syy &amp;amp;&amp;amp; sudo pacman -S archlinuxcn-keyring#安装 oh my zshsh -c &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&amp;quot;# 重启reboot没有权限访问串口 不同于Debian系的dialout，arch系的串口属于用户组uucp 所以只需要将自己添加到uucp组即可。
sudo usermod -a -G uucp username开启 GSConnect gsconnect是kdeconnect的gnome实现，也就比kde的好用那么一点吧（滑稽</description>
    </item>
    
    <item>
      <title>JavaScript 极速入门</title>
      <link>https://blog.frostmiku.com/archives/13/</link>
      <pubDate>Fri, 22 Nov 2019 21:55:00 +0800</pubDate>
      
      <guid>https://blog.frostmiku.com/archives/13/</guid>
      <description>欢迎来到 JavaScrip 极速入坟 门 首先，先把廖雪峰前四章看完 （就是到 面向对象编程 那一章
 JavaScript教程
 接着去看一下这个：
 理解 JavaScript 的 Proto 和 Prototype
 然后就可以开始整活了：
this
var obj = { foo: function () { console.log(this.bar) }, bar: 1 }; var foo = obj.foo; var bar = 2; obj.foo() // 输出啥？ foo() // 输出啥？ array
var bar = [1,2,3] function foo (list) { list.push(4); } foo(bar); // 现在 bar 里面是啥？ obj
function foo(buf){ this.buf = buf; } var bar = new Uint8Array([1,2,3]); var f = new foo(bar); bar[0] = 9; // 现在 f.</description>
    </item>
    
    <item>
      <title>Windows 蓝屏分析简明教程</title>
      <link>https://blog.frostmiku.com/archives/12/</link>
      <pubDate>Sun, 17 Nov 2019 16:00:00 +0800</pubDate>
      
      <guid>https://blog.frostmiku.com/archives/12/</guid>
      <description>前言 &amp;amp; 工具准备 今天室友的电脑蓝屏了&amp;hellip; 虽然以前就经常发生 所以我们来康康是怎么回事！
工欲善其事，必先利其器 在 Microsoft Store 上获取 windbg
简明操作流程  在 WinDbg 界面上的 文件 菜单中选择 Settings 在 Debugging settings 选项卡的 Symbol path 栏中输入SRV*c:\temp*http://msdl.microsoft.com/download/symbols 接着 文件 菜单中选择 open dump file 然后浏览并选择打开 minidump 目录下的文件，一般路径为：C:\Windows\Minidump\XXXXXX-XXXX-XX.dmp 等待系统下载 Symbol 并分析完毕 当出现 Use !analyze -v to get detailed debugging information 时,在下面输入框：!analyze –v 或直接点击 !analyze –v  此时会出现类似如下的信息：
******************************************************************************** ** Bugcheck Analysis ** ********************************************************************************PAGE_FAULT_IN_NONPAGED_AREA (50)Invalid system memory was referenced.</description>
    </item>
    
    <item>
      <title>Whisper 样式一览</title>
      <link>https://blog.frostmiku.com/archives/10/</link>
      <pubDate>Thu, 07 Nov 2019 23:13:00 +0800</pubDate>
      
      <guid>https://blog.frostmiku.com/archives/10/</guid>
      <description>一级标题 你不应当考虑在文本中使用一级标题，这是一种错误的做法。 另外，这段话是普通文本。
二级标题 三级标题 四级标题 五级标题 六级标题 虽然目录对于标题的索引只支持到五级。 但你依然可以在文章中使用六级标题。 这在创建希望引起注意的长文本时会很好用。1 请注意！该标题不宜过长。
 引言块
 /* 代码块 */ #include &amp;lt;stdio.h&amp;gt;int main(void) { printf(&amp;#34;Hello, world!&amp;#34;); return 0; } $$ \lim_{x \to \infty} \exp(-x) = 0 $$
这是一条行内公式$AB＝{xy|x∈A,y∈B }$
   商品 价格     猪肉 ∞   节操 0     Photo by Florian Klauer on Unsplash   Photo by Luca Bravo on Unsplash</description>
    </item>
    
    <item>
      <title>QuickMCU 帮助文档</title>
      <link>https://blog.frostmiku.com/archives/6/</link>
      <pubDate>Wed, 06 Nov 2019 15:38:00 +0800</pubDate>
      
      <guid>https://blog.frostmiku.com/archives/6/</guid>
      <description>本文已严重过时！！！
这里是 QuickMCU 的非正式文档。
波特率 115200。
内部 repl shell VT100（使用 PuTTY 连接就行。
函数内部会对参数类型进行自动转换，多数情况下可以良好的运行。
对应缺失的参数默认会使用 0 或 undefined 代替。
启动流程  自检 打印板子基本信息 执行内部 JavaScript 代码 挂载 spiffs 文件系统并打印用量信息 执行 /c/boot.js 文件中的 JavaScript 代码（如果存在 启动 repl （read-eval-print loop）  Global setTimeout(func,timeout,arg) 和写web时的用法一样。
setInterval(func,timeout,arg) 和写web时的用法一样。
print(str) 打印输出str，参数可以为任何类型（会被自动转换为字符串）
 无返回值
  所有module都是全局中的一个object。 如无特殊说明，module 在全局中的名称皆为： 下文中二级标题的全小写字母。
 OS 提供系统接口
Function sleepMs(ms) 使 JavaScript runtime 暂停指定时间，如无必要不建议使用。
 ms: 整数，sleep的时间，毫秒单位
无返回值
 getTickCountMs() 返回开机到现在所经历的时间，毫秒单位。
 返回整数</description>
    </item>
    
    <item>
      <title>安装用于 CTF 的 Manjaro</title>
      <link>https://blog.frostmiku.com/archives/4/</link>
      <pubDate>Wed, 06 Nov 2019 15:30:00 +0800</pubDate>
      
      <guid>https://blog.frostmiku.com/archives/4/</guid>
      <description>对计算机科学幻灭之后（update:我觉得我又彳亍了），我决定去学信息安全。
于是有了在虚拟机里安装一个Linux的需求&amp;hellip;
在此记录一下我初次的环境建立过程，方便未来可能需要的环境重建（倒不如直接写成脚本..
发行版选择 Linux 发行版选择的是 Manjaro Xfce，为什么选择这个发行版呢？
（VMware Workstation Player 个人使用免费
首先，为什么是Manjaro？ 因为，大名鼎鼎的 Kali Linux 不提供 iso 下载了，官网只有一个种子文件，而且 tuna ustc 的镜像里也没有┑(￣Д ￣)┍
（再说，里面那么多的工具，都有啥？干啥用？怎么用？我都不清楚啊 TAT
Arch Linux 软件源我吹爆，为了能够快速建立就选 Manjaro 喽~
Ubuntu 也不是不能选&amp;hellip;就是感觉有点&amp;hellip;丑&amp;hellip;
其次，为什么是 Xfce？ 毕竟是装在虚拟机里嘛~
既然有宿主了，界面也就不那么重要了。
Xfce 内存占用小，跑得快，默认配置美观&amp;hellip;
安装后要敲的指令 #卸载 Open VMware Toolssudo pacman -R open-vm-tools然后注销，登陆到 root 用户。
因为要用的工具大多数都需要 root，Kali Linux也是这么搞得。
安装 VMware Tools
#切换中国源pacman-mirrors -c China#安装 Vimpacman -S vim#添加 [archlinuxcn]vim /etc/pacman.conf[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.</description>
    </item>
    
    <item>
      <title>一个简单的密码生成算法</title>
      <link>https://blog.frostmiku.com/archives/39/</link>
      <pubDate>Mon, 08 Jun 2015 14:00:00 +0800</pubDate>
      
      <guid>https://blog.frostmiku.com/archives/39/</guid>
      <description>这是个啥？  答： 是小时候写的垃圾，现已被这篇文章取代 2021.9.22
 现如今，每个人都有不少网站的帐号，为每一个帐号设置不同的密码会增加大脑的记忆负担，而使用相同的密码则会引发安全问题。
Simple password generator，是一个简单的密码生成器，但这绝不表示生成的密码是简单密码（弱口令）。通过本生成器可使用户仅需记住一个密码（即所有密码的公匙），来通过算法动态生成实际密码，每次密码皆为动态生成，由公匙确保生成密码的一致性，密码数据不做任何保持，具有较高的安全性。
如何使用 直接上图：
启动后输入储存在大脑 中的密码，然后根据不同网站输入不同的key，生成器会实时计算出唯一的值来作为实际密码，密码不做任何保存处理。
输入 exit 退出程序。
原理 其实就是随机数种子的应用= =|||
还有个缺点，前三（四）位固定是大小写字母、数字（符号）搭配&amp;hellip;
源码 import random lower=&amp;#34;abcdefghijklmnopqrstuvwxyz&amp;#34; upper=&amp;#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;#34; symbols=&amp;#34;!%@#^,./?*;:_&amp;#34; number=&amp;#34;0123456789&amp;#34; def getstr(legth,str1): tmp=&amp;#34;&amp;#34; for i in range(legth): tmp = tmp + random.choice(str1) return tmp def getpwd(pwd,key,legth,havesymbol): passworld=&amp;#34;&amp;#34; random.seed(pwd+key) if(havesymbol): passworld = getstr(1,upper)+getstr(1,lower)+getstr(1,number)+getstr(1,symbols) for i in range(legth-4): switch=random.randint(0,3) if(switch==0): passworld += getstr(1,upper) elif(switch==1): passworld += getstr(1,lower) elif(switch==2): passworld += getstr(1,number) else: passworld += getstr(1,symbols) else: passworld = getstr(1,upper)+getstr(1,lower)+getstr(1,number) for i in range(legth-3): switch=random.</description>
    </item>
    
  </channel>
</rss>
