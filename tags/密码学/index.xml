<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>密码学 on StarWhisper</title>
    <link>https://blog.frostmiku.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/</link>
    <description>Recent content in 密码学 on StarWhisper</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 09 Feb 2021 01:53:00 +0800</lastBuildDate><atom:link href="https://blog.frostmiku.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>浅谈邀请码的生成</title>
      <link>https://blog.frostmiku.com/archives/33/</link>
      <pubDate>Tue, 09 Feb 2021 01:53:00 +0800</pubDate>
      
      <guid>https://blog.frostmiku.com/archives/33/</guid>
      <description>今天自己写项目玩，想要实现一个类似邀请码的机制，没想到小小邀请码还真没那么简单
需求分析 首先是硬性需求：
 不可重复 单射  看到这两点需求，我第一反应就是 Hash，但是Hash需要处理冲突，并不是一个很好的解决方案。另外出于美学之类的考虑，我们还有一些别的需求，毕竟谁也不想面对面分享邀请码的时候拿出来一串 18ce3ca04a725cc6b57d5ec0ae0ccd66 这样的乱码吧
非硬性需求：
 定长 不易被推测出规律 效率高 支持并发 可溯源  仔细思考了一下 Hash 的可行性后我决定放弃这种方案&amp;hellip;
方案分析 群里的菊苣给出了洗牌算法的方案，这是一个预生成的方案 这里就预生成方案统一分析
预生成 讲真，不考虑别的因素，预生成方案确实不错，洗牌算法也非常的棒
这种方案的思想是根据随机生成算法，预先生成一批邀请码，然后将这些邀请码缓存，当用户请求时将其分配给用户，当邀请码分配完时，再生成一批，如此循环。
弊端  每次重新生成时都要检查是否重复 而且多数情况下都为否 邀请码本身需要持久化存储 用户和邀请码的关系需要记录  对于唯一性我啪的一下就想到了 UUID 和 MD5，很快啊 MD5作为一种 Hash 在一开始就被我放弃了，接下来我们看一下 UUID
UUID 引用一下Wikipedia的说法
 通用唯一识别码（英语：Universally Unique Identifier，缩写：UUID）是用于计算机体系中以识别信息数目的一个128位标识符，根据标准方法生成，不依赖中央机构的注册和分配，UUID具有唯一性，这与其他大多数编号方案不同。重复UUID码概率接近零，可以忽略不计。
 这下唯一性是真的强，但是分享一串128位标识符的画面确实也很美&amp;hellip;
没啥好想法的我上网搜了一下，又得到了两种方案，一种类似于Base64，这种没啥好说的，接下来主要说一下另一种方案
密码学方案 这种方案本质上是一个实现了由 用户ID空间 到 邀请码空间 的双射，通过用户ID确定了邀请码的唯一性，同时又可通过反函数来对邀请码溯源，既不需要保存邀请码，又不需要保存关系，针不戳
我们先来写个简单函数实现双射
func test(id uint) { const Chars = &amp;#34;0123456789ABCDEF&amp;#34; const CodeLength = 6 const Base = 16 const Salt = 233 pid := id + Salt // 为了避免用户 ID的直接泄漏，我们可以先加点盐 	var b [CodeLength] uint b[0] = pid for i := 0; i &amp;lt; CodeLength-1; i++ { b[i + 1] = b[i] / Base b[i] = b[i]% Base } fmt.</description>
    </item>
    
    <item>
      <title>一个简单的密码生成算法</title>
      <link>https://blog.frostmiku.com/archives/39/</link>
      <pubDate>Mon, 08 Jun 2015 14:00:00 +0800</pubDate>
      
      <guid>https://blog.frostmiku.com/archives/39/</guid>
      <description>这是个啥？  答： 是小时候写的垃圾，现已被这篇文章取代 2021.9.22
 现如今，每个人都有不少网站的帐号，为每一个帐号设置不同的密码会增加大脑的记忆负担，而使用相同的密码则会引发安全问题。
Simple password generator，是一个简单的密码生成器，但这绝不表示生成的密码是简单密码（弱口令）。通过本生成器可使用户仅需记住一个密码（即所有密码的公匙），来通过算法动态生成实际密码，每次密码皆为动态生成，由公匙确保生成密码的一致性，密码数据不做任何保持，具有较高的安全性。
如何使用 直接上图：
启动后输入储存在大脑 中的密码，然后根据不同网站输入不同的key，生成器会实时计算出唯一的值来作为实际密码，密码不做任何保存处理。
输入 exit 退出程序。
原理 其实就是随机数种子的应用= =|||
还有个缺点，前三（四）位固定是大小写字母、数字（符号）搭配&amp;hellip;
源码 import random lower=&amp;#34;abcdefghijklmnopqrstuvwxyz&amp;#34; upper=&amp;#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;#34; symbols=&amp;#34;!%@#^,./?*;:_&amp;#34; number=&amp;#34;0123456789&amp;#34; def getstr(legth,str1): tmp=&amp;#34;&amp;#34; for i in range(legth): tmp = tmp + random.choice(str1) return tmp def getpwd(pwd,key,legth,havesymbol): passworld=&amp;#34;&amp;#34; random.seed(pwd+key) if(havesymbol): passworld = getstr(1,upper)+getstr(1,lower)+getstr(1,number)+getstr(1,symbols) for i in range(legth-4): switch=random.randint(0,3) if(switch==0): passworld += getstr(1,upper) elif(switch==1): passworld += getstr(1,lower) elif(switch==2): passworld += getstr(1,number) else: passworld += getstr(1,symbols) else: passworld = getstr(1,upper)+getstr(1,lower)+getstr(1,number) for i in range(legth-3): switch=random.</description>
    </item>
    
  </channel>
</rss>
